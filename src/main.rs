use std::collections::HashMap;
use std::env;
use std::fs;
use std::io::Read;
use rand::seq::SliceRandom;
use std::path::Path;

fn main() {

	let res = parse_args();

	let prefix_length: usize = res.0;
	let num_chars:     i32 = res.1;

	if !Path::new("Source Texts").exists() {
		fs::create_dir_all("Source Texts");
	}

	generate_text(prefix_length, num_chars);

}

fn generate_text(prefix_length: usize, num_chars: i32) {

	let dictionary: HashMap<String, Vec<String>> = generate_dictionary(prefix_length);

	// Create vector of all the keys cuz it's honestly easier
	let keys: Vec<&String> = dictionary.keys().collect();

	// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
	let mut new_key = String::from(keys.choose(&mut rand::thread_rng()).unwrap().clone());

	print!("{new_key}");

	// Loop num_chars times
	for _i in 0..num_chars {

		// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		let random_char: &String = dictionary.get(&new_key).unwrap()
		.choose(&mut rand::thread_rng())
		.unwrap();

		print!("{random_char}");

		// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		// ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
		new_key = new_key.chars().skip(1).collect::<String>();
		new_key.push_str(random_char);
	}
}

fn generate_dictionary(prefix_length: usize) -> HashMap<String, Vec<String>> {

	let mut dictionary: HashMap<String, Vec<String>> = HashMap::new();
	let file_paths: Vec<String> = collect_texts();

	// Iterate through every file and add stuff to HashMap
	for file in file_paths
	{
		let content = read_file(&file);
        let chars: Vec<char> = content.chars().collect();

		for i in 0..=chars.len() - prefix_length {

            // Create a prefix string of the prefix_length length
            let prefix: String = chars[i..i + prefix_length].iter().collect();

            // If the prefix exists in the dictionary, append the next character
            if i + prefix_length < chars.len() {
                let next_char = chars[i + prefix_length].to_string();

                // Insert or append to the vector for this prefix
				// Initialize with an empty Vec if doesn't exist
                dictionary.entry(prefix).or_insert_with(Vec::new).push(next_char);
            }
		}

	}

	return dictionary;

}

fn read_file(path: &str) -> String {

    let mut content = String::new();

    let mut file = fs::File::open(path).expect("Failed to open file");

    file.read_to_string(&mut content).expect("Failed to read file");

    return content
}

fn collect_texts() -> Vec<String> {

	// Returns iterator object for some reason but sure that works
	let paths: fs::ReadDir = fs::read_dir("./Source Texts/").unwrap();
	let mut file_names: Vec<String> = Vec::new();

	// Iterate through array and add to vector. This is the STUPIDEST thing I've ever seen and this makes me unreasonably angry there is NO REASON it should be like this at all
    for path in paths {

        if let Ok(entry) = path {

            if let Some(name) = entry.file_name().to_str() {

				// I don't even know why it makes me do this to be honest, really starting to hate this language
				let full_path = format!("./Source Texts/{}", name);
                file_names.push(full_path);
            }
        }
    }

	if (file_names.len() == 0) {
		panic!("Must add files to Source Texts");
	}

	return file_names;
}

fn parse_args() -> (usize, i32) {

	let args: Vec<String> = env::args().collect();

	if args.len() < 3  {
		panic!("Usage: TextGenerator <prefix_length> <num_chars>");
	}

	// Parse stuff from args yeah yeah
	let prefix_length: usize = args[1].parse::<usize>().unwrap();
	let num_chars:     i32 = args[2].parse::<i32>().unwrap();

	// Input validation
	if prefix_length < 1 || num_chars < 1 {
		panic!("Prefix length and number of characters to generate must be >= 0!");
	}

	return (prefix_length, num_chars);
}
